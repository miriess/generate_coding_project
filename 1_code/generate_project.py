"""

"""

import os
import sys

class project_gen:
    def __init__(self, p_name='new_project', f_list=['main_code.py']):
        self.project_name=p_name
        self.file_list=f_list

    def create_folders(self):
        os.mkdir(self.project_name)
        os.chdir(self.project_name)
        os.mkdir('0_data')
        os.mkdir('1_code')
        os.mkdir('2_pipeline')
        os.mkdir('3_output')
        for x in self.file_list:
            i = self.file_list.index(x)
            if x.split('.')[1] == 'ipynb':
                iPy = open(f'1_code/{i}_{x}', 'w+')
                iPy.write(jup_nb_file)
                iPy.close()
            # elif (x.split('.')[1] != 'R') or (x.split('.')[1] != 'py'):      # I thought the placeholder might be nice, but having a dummy-file is useful even if it cannot be properly opened: It opens the right program by default...
            #     filetype = x.split('.')[1]
            #     ph = open(f'1_code/{i}_placeholder_{filetype}_file.txt', 'w+')
            #     ph.write(f'Replace with a .{filetype} file.')
            #     ph.close()
            else:
                open(f'1_code/{i}_{x}', 'w+').close()
            folder_name = x.split('.')[0]
            os.mkdir(f'2_pipeline/{i}_{folder_name}')
            for y in ['tmp', 'store', 'out']:
                os.mkdir(f'2_pipeline/{i}_{folder_name}/{y}')

    def create_starting_files(self):
        read_me=open('README.md', 'w+')
        read_me_lines = [
            '# Project Title',
            '*Give an explanation about the project.*',
            '## Motivation',
            '*Why is this project? What is its purpose.*',
            '## Features',
            '*What does it do and why is that awesome?*',
            '## Code Example',
            '*Show how the project does what it does.*',
            '## How to use?',
            '*What to do to use it - concise and direct.*'
            ]
        read_me.write('\n'.join(read_me_lines))
        read_me.close()
        structure_explanation=open('structure_README.md', 'w+')
        struc_lines = [
            '# Rules',
            '1. Never modify `0_data`.',
            '2. Only save to `pipeline` folder.',
            '3. Only load from `0_data` or `out`.',
            '4. Anything in `tmp` can be deleted',
            '',
            '## Explanations',
            '- `0_data` contains all the input data that is either retrieved from external sources or created manually. For example, this includes data downloaded from databases such as Compustat, but also an Excel sheet with data that you manually classiBed. The core principle here is that nothing in this folder should ever be modiBed. The data in this folder should remain identical to the way that you have retrieved or manually created it.',
            '- `1_code` contains all your code fils. This includes, for example, code fils for Python, Stata, R, or SAS (or a combination thereof). Furthermore, I recommend to name your code files starting with a number to indicate the order of execution. This makes it obvious in what order fils should be executed (which you could also further formalize in a *.bat / .sh* file if you wanted to).',
            '- `2_pipeline` contains a separate sub-folder for each code file included in the 1_code folder, they correspond based on the name (minus the file extension). This implies, for example, that a code file *0_load_data.ipynb* in 1_code would have a sub-folder in the 2_pipeline folder with the name *0_load_data*. The main idea is that all output generated by a code file ends up in their corresponding pipeline folder. This makes it very easy to understand how data is flowing between code files as the data location indicates where it was generated. To further organize the generated outputs, I advise the following folders in each sub-folder: out, store, and tmp.',
            '- `2_pipeline -> sub-folder -> out` contains fils that you save with the intention of loading them in a future code file. These are usually the "end-products" of the current code file.',
            '- `2_pipeline -> sub-folder -> store` contains files that you save with the intention of loading them in the current code file. This is, for example, used in scenarios where it takes a while to run parts of your code and to avoid having to re-run these parts every time you might want to intermittently save the progress of your generated data to the store folder.',
            '- `2_pipeline -> sub-folder -> tmp` contains files that you save for inspection purposes or some other temporary reason. The basic principle is that you should not have to worry about anything in the tmp folder being deleted as it only serves a temporary purpose.',
            '- `3_output` contains any final output files that are intended to go into the paper. This includes files such as tables and figures.',
            '',
            '## Additional Rules',
            '- Only load data into the code from either `0_data` or any of the `out` folders in the `2_pipeline` sub-folders.',
            '   - Only load data from `out` folders belonging to code files that are executed before the current file.',
            '- Always set working directory as top-level project directory and use relative paths.'
            ]
        structure_explanation.write('\n'.join(struc_lines))
        structure_explanation.close()
        git_ig = open('.gitignore', 'w+')          #geht das wirklich hier schon?
        git_ig.write('structure_README.md')
        git_ig.close()

#    def create_git(self):




if __name__ == '__main__':
    project_name = sys.argv[1]
    if len(sys.argv) > 2:
        PROJ = project_gen(p_name=project_name, f_list=sys.argv[2:])
    else:
        PROJ = project_gen(p_name=project_name)
    PROJ.create_folders()
    PROJ.create_starting_files()
